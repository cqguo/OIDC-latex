\appendix

\section{Formal Model of \usso}
\label{appendix-model}

In this section, we present a formal model for \usso, which closely follows the description in Section~\ref{implementations} and the implementation of the protocol. This model provides a basis for the formal analysis of the security w.r.t. authentication and privacy properties presented in Section~\ref{sec:analysis}.

\vspace{1mm} \noindent {\bf Web Model. } We followed the formal analysis for the BrowerID~\cite{BrowserID} and SPRESSO~\cite{SPRESSO} protocols to define the web system based on the general Dolev-Yao (DY) web model. 

Similar to SPRESSO~\cite{SPRESSO}, we simplified the handling of nonces, removed non-deterministic choices wherever possible, and added the HTTP Referer header and the HTML5 noreferrer attribute for links. Besides, we adopted most of the definitions for the web model presented in Section 3 of \cite{SPRESSO} in this proof. Therefore, we do not include and repeat the full details of these definitions here. We refer interested readers to Section 3 and Appendix A-C in \cite{SPRESSO}.

In summary, the web model defines the communication model (i.e., messages, terms, events, atomic processes, a system consisting of atomic processes, runs, and scripting processes), web system in a tuple of $(\mathcal{W}, \mathcal{S}, \mathsf{script}, E^0)$, and web browsers modeled as Dolev-Yao processes denoted as $(I^p, Z^p, R^p, s_0^p)$. 

\vspace{1mm} \noindent {\bf Formal Model of \usso.} We model \usso\ as a web system $\mathcal{UWS}=(\mathcal{W}, \mathcal{S}, \mathsf{script}, E^0)$. The set $\mathcal{W} = \mathsf{Hon} \cup \mathsf{Web} \cup \mathsf{Net}$ consists of an $\mathsf{IDP}$ for the web server of the identity provider, a finite set of web servers $\mathsf{RP}$ for the relying parties, 
a finite set of web browsers $\mathsf{B}$, %a finite set $\mathsf{DNS}$ of DNS servers, 
a finite set of web attacker processes (in $\mathsf{Web}$), and a network attacker process (in $\mathsf{Net}$), with $\mathsf{Hon}:=\mathsf{IDP}\cup\mathsf{RP}\cup\mathsf{B}$. $\mathcal{S}$ denotes the set of scripts with an RP script and an IdP script, whose respective string representations are defined by the mapping script, denoted as $\mathsf{script_{rp}}$ and $\mathsf{script_{idp}}$, respectively. Finally, the set $E^0$ only the trigger events of the form $<a,a,\mathsf{TRIGGER}>$ for every IP address $a$ in the web system.

\vspace{1mm}\noindent \underline{\em Overview of the Processes.} We briefly sketch the processes and the scripts in $\mathcal{W}$ and $\mathcal{S}$: 
(1) Browsers $\mathsf{B}$ as defined in the web model; 
(2) $\mathsf{RP}$ is a web server that knows four distinct paths: $\mathsf{/script}$, which returns $\mathsf{script_{rp}}$; $\mathsf{/LoginSSO}$, which redirects the browser to the IdP script; $\mathsf{/stateNegotiation}$, which accepts POST requests with data ($t$) obtained from $\mathsf{script_{rp}}$ running in the browser and returns the RP certificate; and $\mathsf{/uploadToken}$, which accepts login data obtained from $\mathsf{script_{rp}}$. 
(3) $\mathsf{IDP}$ is a web server that knows four distinct paths: $\mathsf{/script}$, which returns $\mathsf{script_{idp}}$; $\mathsf{/authentication}$, which authenticates the user if he has not been authenticated yet; $\mathsf{/reqToken}$, which requests session cookie if the user has logged in; and $\mathsf{/authorize}$, which verifies $PID_{RP}$, computes $PID_U$, obtains the user's authorization for the request, and returns the scope of the authorized attributes. %And (4) each DNS server $\mathsf{DNS}$ contains the assignment of domain names to IP addresses and answers DNS requests accordingly. 

\vspace{1mm}\noindent \underline{\em Web Browsers.} A browser is modeled as an atomic DY process $(I^b, Z^b, R^b, s_0^b)$ for each $b \in \mathsf{B}$. The web browser model of \usso\ is simpler than the one in SPRESSO. So, we adopted several atomic processes of the web browsers defined in SPRESSO (Appendix C.2 in \cite{SPRESSO}) and reused them directly, which includes the atomic processes for ``prepare headers'', ``save message'', ``execute a script'', ``process an HTTP response'', etc. 

\vspace{1mm}\noindent \underline{\em Identity Provider.} The IdP is also modeled as an atomic DY process $(I^i, Z^i, R^i, s_0^i)$ with the address $I_r:=addr(i)$. Its initial state $s_0^i$ contains a list of its domains and (private) TLS keys, a list of users and identities ($u$s), and a private key
for signing identity tokens. IdP accepts only HTTPS requests and manages the login session of the user. In a login flow, $i$ will receive an HTTP GET request for the path $\mathsf{/script}$, and returns the $\mathsf{script_{idp}}$. We describe the relation $R^i$ as a non-deterministic algorithm (Algorithm 1 in Appendix C). 

\vspace{1mm}\noindent \underline{\em Relying Parties.} Similarly, a relying party in a \usso\ web system is modeled as an atomic DY process $(I^r, Z^r, R^r, s_0^r)$ with the address $I_r:=addr(r)$. Its initial state $s_0^r$ contains its domains and the private keys associated with the domains. RP accepts only HTTPS requests and manages two types of sessions: the login session is used during user login and the service session (identified by a {\em service token}) denotes the phase in which the user uses the RP service. In \usso, the service token is in the form of $\langle IDToken, Acct \rangle$. In a login flow, $r$ will receive an HTTP GET request for the path $\mathsf{/script}$ and return the $\mathsf{script_{rp}}$. We describe the relation $R^r$ as a non-deterministic algorithm (Algorithm 2 in Appendix C). 

\vspace{1mm}\noindent \underline{\em Scripts.} The \usso\ web system also have two scripts, which represent a relation taking a term as input and
outputting a new term. We describe the relations $\mathsf{script_{idp}}$ and $\mathsf{script_{rp}}$ formally as non-deterministic algorithms, as shown in Algorithms 3 and 4 in Appendix C.

\vspace{1mm}\noindent \underline{\em Web Attackers.} A web attacker, i.e., $wa \in \textsf{Web}$, is an attacker process that uses only his own addresses for sending and listening. It cannot listen to traffic intended for other processes. 

\vspace{1mm}\noindent \underline{\em Network Attackers.} A network attacker, i.e., $na \in \textsf{Net}$, is an attacker process that uses all addresses for sending and listening. 
A web attacker does not spoof sender addresses, while a network attacker may spoof all addresses. 

Finally, the browsers and RPs can become corrupted. The states $Z^p$ of a web browser atomic process $p$ is defined in {\bf Definition 35} in \cite{SPRESSO}, which includes a term $isCorrupted$. For an honest entity, the state $s.isCorrupted=\perp$. Otherwise, it could be $\textsf{FULLCORRUPT}$ or $\textsf{CLOSECORRUPT}$ (i.e., a closed browser later used by a malicious user). When receiving a special message $\mathsf{CORRUPT}$, they will collect all incoming messages in their state and send out messages derivable from their state, like any attacker process.

\section{\usso\ Security Proofs}
\label{appendix-security}

Let  $\mathcal{UWS}^{auth}$ denote a \usso\ web system for authentication analysis. As $\mathcal{UWS}^{auth}$ adopted the fundamental atomic processes of the web browsers defined in \cite{SPRESSO}, it also offers the general properties provided by these processes in a SPPRESSO web system, which are presented in Definitions 53-63 in Appendix F1 of \cite{SPRESSO}. So, we will use them directly in following proofs without further elaboration.

Based on the web model presented in Appendix~\ref{appendix-model}, we formally define the two security properties {\bf (A)} and {\bf (B)} that \usso\ fulfills as follows. 
%Note that the RP service token should be defined as $\langle IDToken$, $Acct \rangle$.

\begin{definition}
$\mathcal{UWS}^{auth}$ is considered secure if for every run $\rho$ of $\mathcal{UWS}^{auth}$, every state ($S^j$, $E^j$, $N^j$) in $\rho$, every $r \in$ $\mathtt{RP}$ that is honest, every RP service token of the form $\langle IDToken, Acct \rangle$ recorded in $S^j$($r$).$\mathtt{serviceTokens}$, the following two conditions are satisfied:

(A) If $\langle IDToken, Acct\rangle$ is derivable from the attacker's knowledge in $S^j$, i.e., $\langle IDToken, PID_U \rangle \in d_{\emptyset}$($S^j$($\mathtt{attacker}$)), then it follows that the browser b owning $Acct$ is fully corrupted in $S^j$, i.e., the value of $isCorrupted$ is $\mathtt{FULLCORRUPT}$, or $\mathtt{governor}$($ID_U$), where $Acct=[ID_U]S^j(r).ID_{RP}$, is not an honest IdP in $S^j$.

(B) If the request corresponding to $\langle IDToken, Acct \rangle$ was sent by some $b \in \mathtt{B}$ that is honest in $S^j$, then $b$ owns $ID_U$ that satisfies $Acct=[ID_U]S^j(r).ID_{RP}$.
\end{definition}

Properties (A) and (B) are proved separately. Following \cite{SPRESSO}, the strategy used to prove either property is by assuming that the respective property is not satisfied and showing that it leads to a contradiction.

\vspace{1mm}\noindent {\bf Proof of Property A.} 
Similar to \cite{SPRESSO}, we first assume that there exists a $\mathcal{UWS}^{auth}$ that is not secure, and then show that it will lead to a contradiction. Thereby, all \usso\ web systems are secure with regard to Property (A), which is defined as follows.

% Based on the above definition and following the formal analysis in \cite{SPRESSO}, we define Property A as follows.

\begin{definition}
$\mathcal{UWS}^{auth}$ is secure with respect to Property A if, for every run $\rho$, every state ($S^j$, $E^j$, $N^j$) in $\rho$, every $r \in \mathtt{RP}$ that is honest in $S^j$, every RP service token of the form $\langle IDToken$, $Acct \rangle$ recorded in $S^j$($r$).$\mathtt{serviceTokens}$ and derivable from the attacker's knowledge in $S^j$ (i.e., $\langle IDToken$, $Acct \rangle \in d_{\emptyset}$($S^j$($\mathtt{attacker}$))), it follows that the browser $b$ owning $Acct$ is fully corrupted in $S^j$, i.e., the value of $isCorrupted$ is $\mathtt{FULLCORRUPT}$, or $\mathtt{governor}$($ID_U$), where $Acct=[ID_U]S^j(r).ID_{RP}$, is not an honest IdP in $S^j$.
\end{definition}

First, let $I:=\mathtt{governor}$($i$), which is an honest IdP and never leaks its signing key (see Algorithm 1 in Appendix C%~\ref{alg:idp}
). Therefore, the signed subterm $Content:= \langle PID_{RP}, PID_U, s'.Issuer, Validity \rangle$, $Sig:= SigSign(Content, s'.SK)$ and $IDToken:= \langle Content, Sig \rangle$ is created by the IdP $I$.  The honest IdP creates signatures only in Algorithm 1 (Line 48-50).%~\ref{alg:idp}.

%(Same as Lemma 4 in SPRESSO)
\begin{lemma}
\label{lemma-user-request}
Under the assumption above, only browser b can issue a request $req$ that triggers the IdP $I$ to create the signed term $IDToken$. The request was sent by b over HTTPS using I's public HTTPS key.
\end{lemma}

%The proof is same as the Lemma 4's proof in SPRESSO.
\begin{proof}
We adapted the proof for Lemma 4 in SPRESSO. 
Consider two cases for $req$: first, if the user is not logged in with the identity $u$ at $I$, i.e., the browser does not have any session cookie for $u$, then the request has to carry the password matching the identity $u$, which is known only to $b$. Now, if $b$ is honest in $s_j$, it should have not sent the secret to any party except $I$ over HTTPS. If $b$ is close-corrupted, it should have not disclosed the secret to any other parties before being corrupted. Since the IdP is honest and will not disclose the secret, it implies that only $b$ can initiate the request $req$. In the second case, if the user has logged in to $I$, the corresponding session id can only be retrieved by $I$ from logging in and sent to $b$ in the form of cookie. $b$ sends the cookie only to $I$, so $b$ is the only atomic DY process that can initiate the request $req$.

As $req$ is sent over HTTP, it cannot be read of altered by any other party. $req$ contains $PID_{RP}$, from which $PID_U$ is computed as $PID_U:=[ID_U]PID_{RP}$ for $IDToken$.
%It can be proved that $IDToken$ only contains the $PID_U:=[ID_U]PID_{RP}$, while $PID_U$ is provided by $b$ and $b$ owns the password of $ID_U$.
\end{proof}

%(Same as Lemma 5 in SPRESSO) 
\begin{lemma}
In the browser $b$, the request $req$ was triggered by script\_idp loaded from the origin $\langle d, S \rangle$ for some $d \in \mathtt{dom}(I)$.
\end{lemma}

%The proof follows the Lemma 5's proof in SPRESSO.
\begin{proof}
We adapted the proof for Lemma 5 in SPRESSO. 
For browser $b$, its initial state $s^b_0$ has a list of secrets containing an entry $\langle \langle d, S \rangle, s \rangle$. For $d \in \mathtt{dom}(I)$, $\langle d, S \rangle$ is the only origin that has access to the secret. So, only the IdP's script $script\_idp$ owns the password of $ID_U$ and thus can request the $IDToken$ from $I$.
\end{proof}

%(Same as Lemma 6 in SPRESSO)
\begin{lemma}
In the browser $b$, the script script\_idp receives the response to the request req (and no other script), and at this point, the browser is still honest.
\end{lemma}

\begin{proof}
We adapted the proof for Lemma 6 in SPRESSO. 
When $b$ becomes close-corrupted, it discards any information about pending requests in its state including TLS keys. Therefore, the closed-corrupted browser cannot receive $IDToken$ responding to $req$ initiated by the honest browser $b$.
\end{proof}

%(Same as Lemma 8 in SPRESSO) 
\begin{lemma}
The script script\_idp forwards IDToken only to the script script\_rp loaded from the origin $\langle d_r, S \rangle$.
\end{lemma}

\begin{proof}
We adapted the proof for Lemma 8 in SPRESSO. 
The honest $script\_idp$ that runs in the honest browser $b$ forwards $IDToken$ only to the origin $\langle Cert_{RP}.Enpt_{RP}, S \rangle$, as shown in Algorithm 3%~\ref{alg:script_idp}
(Lines 9, 16, 19, 21, 38, 39, 59, and 60). 
$IDToken$ holds $PID_{RP} \equiv [t]Cert_{RP}.ID_{RP}$ and $t$ that is a one-time random number. The relation of $ID_RP$ and $Enpt$ is guaranteed by the signature generated by the IdP $I$. 
\end{proof}

%Same as Lemma 9 in SPRESSO)
\begin{lemma}
From the RP document, IDToken is sent only to the RP r and over HTTPS.
\end{lemma}

\begin{proof}
We adapted the proof for Lemma 9 in SPRESSO. 
From the definition of the RP script and as also shown in Algorithm 4, %~\ref{alg:script_rp}.
$script\_rp$ of the origin $\langle Cert_{RP}.Enpt_{RP}, S \rangle$ would send $IDToken$ only to the corresponding RP $r$. 
\end{proof}

\vspace{2mm}

With Lemmas 2 and 3, we show that only the honest browser and the honest IdP script can trigger an identity token request and $PID_{RP}$ in the request cannot be leaked or altered by the attacker (Property A1). 
With Lemmas 4-6, we show that $IDToken$, once it was signed by the IdP $I$, would be transferred to the honest browser $b$, the IdP script, the RP script, and the target RP, which do not leak it to any attacker. Therefore, it cannot be known to ({\em ID Token Confidentiality}) or altered by ({\em ID Token Integrity}) the attacker, which is denoted as Property A2.

Now, for $\langle IDToken$, $Acct \rangle$ to be created and recorded in $S^j(r)$, an identity toke request $req$ has to be created and sent, which can be done only by $I$, the IdP script, and $b$. None of them will leak the response token to the attacker. This is a contradiction to the assumption, where we assumed that $\langle IDToken$, $Acct \rangle \in d_{\emptyset}$($S^j$($\mathtt{attacker}$)). 

If collusive attackers are not considered, we could prove that every $\mathcal{UWS}^{auth}$ is secure in the sense of Property A. However, in \usso, a malicious RP could share a valid $IDToken$ it received with a malicious user, who replays it to another honest RP, if $t^{adversary}$ would satisfy $IDToken.PID_{RP} \equiv [t^{adversary}]ID_{RP}^{honest}$. Therefore, we need to further prove Theorems 2 and 3 in Section 5.1.

%The proofs show that the $IDToken$ is only sent to the honest browser (Lemma 1-7) and  target RP (Lemma 8-9). Above proofs can be reduced to the {\color{blue}Confidentiality and Integrity Properties}, simply described as the {\color{blue} Theorem 3 and 4} in section 5.2.
%---- we may not need Lemma 7
%These Lemmas are sufficient to prove the security of the SPRESSO web systems, however, they are not enough to prove the security of the \usso\ web systems. So far, they only guarantee that $IDToken$ is forwarded to the target RP. However, in \usso, a malicious RP could share a valid $IDToken$ it received with a malicious user, who replays it to another honest RP, if $t^{adversary}$ would satisfy $IDToken.PID_{RP} \equiv [t^{adversary}]ID_{RP}^{honest}$.
% We prove in Lemma 7 that this is not possible.

% \begin{lemma}
% The $t^{adversary}$ is not derivable from the attacker's knowledge in $S^j$ (i.e., $\langle IDToken$, $Acct \rangle \in d_{\emptyset}$($S^j$($\mathtt{attacker}$))), which satisfies that $IDToken.PID_{RP} \equiv [t^{adversary}]ID_{RP}^{honest}$.
% \end{lemma}

% \begin{proof}
% This Lemma is equivalent to the Theorem 2 in Section 5.2 for the {\em RP Designation} Property.
% \end{proof}


\vspace{3mm}\noindent {\bf Proof of Property B.} This property is formally defined for a \usso\ web system $\mathcal{UWS}^{auth}$ as follows. 

\begin{definition}
\label{def:B}
$\mathcal{UWS}^{auth}$ is considered secure (with respect to Property B) if for every run $rho$ of $\mathcal{UWS}^{auth}$, every state ($S^j$, $E^j$, $N^j$) in $rho$, every $r \in \mathtt{RP}$ that is honest in $S^j$, every RP service token of the form $\langle IDToken$, $Acct \rangle$ recorded in $S^j$($r$).$\mathtt{serviceTokens}$, with the request corresponding to $\langle IDToken$, $Acct \rangle$ sent by some $b \in B$ that is honest in $S^j$, b owns Acct.
\end{definition}

To prove Property (B), we first adapted Lemma 10 in SPRESSO to show that the request corresponding to $\langle IDToken$, $Acct \rangle$ sent by honest $b$ is loaded from $script\_rp$. 

Then, we prove that $IDToken$ uploaded by an honest $b$ can only be associated with $Acct$ that is owned by $b$ (known as the {\em User Identification} property), which is proved in Theorem 3. This proof is different from the one used in SPRESSO, as \usso\ assumes that malicious user and malicious RP could collude to manipulate the transformation of the pseudo-identities or replay the previously received identity tokens.

% \begin{lemma}
% For every $IDToken$ uploaded by honest $b$ during authentication, the honest $r \in RP$ can always derive the service token of the form $\langle IDToken$, $Acct \rangle$ recorded in $S^j$($r$).$\mathtt{serviceTokens}$, where b owns Acct. 
% \end{lemma}

% \begin{proof}
% The RP accepts the user's identity (Line 43 in Algorithm 2), 
% And the identity is generated at Line 38, based on the $PID_U$ retrieved from the $IDTpken$ and the trapdoor $t^{-1}$.
% The $t^{-1}$ is generated in Line 13 and set in Line 14. It is never changed, as the multiplicative inverse of $t$.
% The $IDToken$ is issued at Line 50 in Algorithm~\ref{alg:idp}.
% The IdP generates the $PID_U$ based on the $PID_{RP}$ and $ID_U$ related to $b \ in \mathtt{Browser}$.

% An attacker may allure the honest user to upload the $IDToken \in d_{\emptyset}$($S^j$($\mathtt{attacker}$)) to honest $r \in \mathtt{RP}$, so that there may be $Acct \in d_{\emptyset}$($S^j$($\mathtt{attacker}$)).
% However, while $b$ has already negotiated the $PID_{RP}$ with $r$, the opener of the $script\_idp$ must be the $script\_rp$.

% As the $t$ generated at Line 7, Algorithm~\ref{alg:script_idp}, and $PID_{RP}$ generated at Line 21 in Algorithm~\ref{alg:script_idp}.
% The $t$ is only sent to $script\_rp$ at Line 8 in Algorithm~\ref{alg:script_idp}, and the $script\_rp$ receives it at Line 18 in Algorithm~\ref{alg:script_rp}.
% The $PID_{RP}$ is sent to the honest IdP at Lines 23 and 50 in Algorithm~\ref{alg:script_idp}, which is used for generating the $IDToken$.

% For every $IDToken$ sent by honest $b$ and honest $r$, there must be $IDToken.PID_{RP} \equiv [t]Cert_{RP}.ID_{RP}$, $IDToken.PID_U \equiv [ID_U]IDToken.PID_U$ and $Acct \equiv [t^{-1}]IDToken.PID_U$. According to the proof of {\color{blue}Theorem 2} in section 5.2, the $Acct$ must be owned by honest $b$ ($Acct \equiv [ID_U]S^j(r).ID_{RP}$, where $ID_U$ is related to $b$), which can be define as the  {\color{blue} User Identification Property} .
% \end{proof}

%With the above proofs, we now can guarantee that every $\mathcal{UWS}^{auth}$ system satisfies the requirements in Definition~\ref{def:B}, therefore $\mathcal{UWS}$ must be secure of Property B.
