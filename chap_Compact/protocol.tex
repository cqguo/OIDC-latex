\section{Design of UPRESSO}
\label{sec:UPRESSO}
In this section, we provide designs of UPRESSO, a secure and privacy-preserving SSO system.
First, we present the functions of privacy-preserving ID transformation which achieve the trapdoor user identification and transformed receiver designation. Then, we provide an overview of UPRESSO and describe the detailed protocol for providing the SSO service. Finally, we discuss the compatibility of UPRESSO with OIDC.

\subsection{Functions of privacy-preserving ID transformation}
\label{subsec:overview}
The three functions $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$, $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$  are essential for the trapdoor user identification and  transformed receiver designation.
In UPRESSO, these functions are constructed based on discrete logarithm cryptography with the public parameters $p$, $q$, $g$ and $L$,
 where  $p$ is a large prime defines the finite field $GF(p)$, $L$ is the length of $q$, $q$ ($2^{L-1} < q < 2^L$) is a prime divisor of ($p-1$), and $g$ is a generator of order $q$.
%the prime number $q$  is the order of a multiplicative subgroup of $GF(p)$, which is generated with the generator $g$ by $\{g\ mod\ p, g^2\ mod\ p, ..., g^{q-1}\ mod\ p, 1=g^q\ mod\ p\}$.

In UPRESSO, IdP assigns a  unique random number as  $ID_U$ ($0 < ID_U <q $)  at the user's registration, and a unique $ID_{RP}$ at the RP's initial registration. The $ID_{RP}$ is generated using Equation~\ref{equ:IDRP}, where $r$ is a random number ($1 < r < q$).

\begin{equation}
    ID_{RP} = g^{r} mod \ p
   \label{equ:IDRP}
\end{equation}


For each login, the RP chooses a random number $N_{RP}$ ($1 < N_{RP}<q $), the user chooses a random number $N_{U}$ ($1 < N_{U}<q $). Then, the RP and user cooperatively  generate $PID_{RP}$ using the function $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ as Equation~\ref{equ:PIDRP}. The function $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ satisfies the requirements described in Section~\ref{subsec:challenges}. That is, the function $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ is invoked to generate $PID_{RP}$ for each login, while IdP  fails to derive $ID_{RP}$ from $PID_{RP}$ and cannot find the relation among ${PID_{RP}}$s for a same RP, which is ensured by the discrete logarithm cryptography.
Moreover, $N_{U}$ and $N_{RP}$  serves as the nonce which ensures that the $PID_{RP}$ (also identity proof) is exactly constructed for this login, and
the cooperation between the user and RP prevents the malicious user and RP from controlling the  $PID_{RP}$. For example, the malicious user fails to make a correct RP accept a $PID_{RP}$ used in another login, while the collusive RPs fail to use a same or correlated $PID_{RP}$s for different logins.


 \begin{equation}
    \mathcal{F}_{ID_{RP} \mapsto PID_{RP}}: {ID_{RP}}^{N_{U}* N_{RP}} mod \ p
   \label{equ:PIDRP}
   \end{equation}

For the user $ID_U$ to login at an RP with a privacy-preserving identifer $PID_{RP}$, IdP calculates the user's privacy-preserving identifer $PID_U$ using the function  $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ as Equation~\ref{equ:PIDU}. The function $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ satisfies the requirements described in Section~\ref{subsec:challenges}.
Combining Equation~\ref{equ:IDRP}, ~\ref{equ:PIDRP} and~\ref{equ:PIDU}, we get that  $PID_U$ equals to $g^{r*N_U*N_{RP}*ID_U}\ mod \ p$.
The discrete logarithm cryptography ensures that the RPs fail to derive $ID_U$ from $PID_U$,
nor link a user's $PID_U$s at different RPs who can never  know $r$ and $ID_U$. %have different $ID_{RP}$. %discrete logarithm of $ID_{RP}$ modulo $ID_{RP}^'$


\begin{equation}
 \mathcal{F}_{ID_{U} \mapsto PID_{U}}: {PID_{RP}}^{ID_U} \ mod \ p
 \label{equ:PIDU}
\end{equation}

Finally, the RP derives $Account$ for the user with the function $\mathcal{F}_{PID_{U} \mapsto Account}$ as Equation~\ref{equ:Account}. Here, the value $(N_U*N_{RP})^{-1} mod \ q$ is the trapdoor $t$. As $q$ is a prime number, $1< N_U < q$ and $1< N_{RP} < q$, therefore $q$ is coprime to $N_U*N_{RP}$, and the $t$ that satisfies $t*(N_U*N_{RP}) = 1\ mod \ q$ always exists. The function $\mathcal{F}_{PID_{U} \mapsto Account}$ satisfies the requirements described in Section~\ref{subsec:challenges}.  As shown in Equation~\ref{equ:AccountNotChanged},  for a user's multiple logins at an RP, $\mathcal{F}_{PID_{U} \mapsto Account}$ outputs an unchanged $Acount$  which equals to ${{ID_{RP}}^{ID_U}} mod \ p$.
Same as the analysis of $PID_U$, the collusive RPs fail to derive $ID_U$ from $Account$ nor link a user's $Account$s due to the different and unknown $r$s.

 \begin{equation}
   \mathcal{F}_{PID_{U} \mapsto Account}: {PID_U}^{(n_U*n_{RP})^{-1} mod \ q} mod \ p
   \label{equ:Account}
   \end{equation}

The \textbf{trapdoor user identification} is supported with these three functions.
For a user's multiple logins, each PR obtains the different $PID_U$s and the corresponding $t$s , then derives the unchanged $Account$  as shown in Equation~\ref{equ:AccountNotChanged}.
The function $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ prevents the curious IdP from linking the $PID_{RP}$s of different logins at an RP, and therefore avoids  the  IdP-based access tracing.
The functions $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$ prevents the collusive RPs from linking a user's $PID_U$s and $Account$s at different RPs, and therefore avoids the RP-based identity linkage.
 \begin{multline}\label{equ:AccountNotChanged}
   Account =  {PID_{U}}^{t} mod \ p  \\
   = {({PID_{RP}}^{ID_U})}^{{(N_U*N_{RP})^{-1} mod \ q}} mod \ p \\
   = {ID_{RP}} ^ {ID_U * N_U * N_{RP} *t\ mod\ q} = {ID_{RP}}^{ID_U} mod \ p
 \end{multline}

The \textbf{transformed receiver designation} is also supported with the efficient functions $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$, together with  a user-centric verification.
The $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ ensures that the user and RP cooperatively generate a fresh $PID_{RP}$  for a user's login,
 while $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ ensures that the IdP generates the exact $PID_U$ for the $ID_U$ who logins at $PID_{RP}$.
The IdP will bind $PID_{U}$ with $PID_{RP}$ in the identity proof, which designates this identity proof to $PID_{RP}$.
In the user-centric verification,  both the user and RP checks the uniqueness of $PID_{RP}$, while the user further checks that $PID_{RP}$ is exactly generated for the RP $ID_{RP}$,  and then sends the identity proof  only  to this RP. Therefore, the $PID_{RP}$ is designated to $ID_{RP}$.
Finally, the transformed receiver designation is provided through the two-step designations.


\begin{table}[tb]
    \caption{The notations used in UPRESSO.}
    \centering
    \begin{tabular}{|c|c|c|}
    \hline
    {Notation} & {Definition} & {Attribute} \\
    \hline
    {$p$} & {A large prime.} & {Long-term} \\
    \hline
    {$q$} & {A large prime.} & {Long-term} \\
    \hline
    {$L$} & {Length of $q$. } & {Long-term} \\
    \hline
    {$g$} & {A generator of order $q$. } & {Long-term} \\
   % \hline
    %{$SK_{ID}$, $PK$} & {The private/public key to sign/verify identity proof.} & {System-unique} \\
    \hline
    {$ID_U$} & {User's unique identifier.} & {Long-term} \\
    \hline
    {$PID_U$} & {User's privacy-preserving identifier.} & {One-time}\\
    \hline
    {$Account$} & {User's identifier at an RP.} & {Long-term} \\
    \hline
    {$r$} & {Secret value for $ID_{RP}=g^r\ mod\ p$.} & {Long-term} \\
    \hline
    {$ID_{RP}$} & {RP's original identifier.} & {Long-term} \\
    \hline
    {$PID_{RP}$} & {RP's privacy-preserving identifier.} & {One-time} \\
    \hline
    {$N_U$} & {User-generated random nonce for $PID_{RP}$.} & {One-time} \\
    \hline
    {$N_{RP}$} & {RP-generated random nonce for $PID_{RP}$.} & {One-time} \\
    \hline
    {$Y_{RP}$} & {Public value for $n_{RP}$, $(ID_{RP})^{N_{RP}} \ mod\ p$.} & {One-time} \\
    \hline
    {$t$} & {A trapdoor, $t=(N_U*N_{RP})^{-1} mod \ q$.} & {One-time} \\
    \hline
    {$Cert_{RP}$} & {An RP certificate. } & {Long-term} \\
    \hline
    {$SK$, $PK$} & {The private/public key of IdP. } & {Long-term} \\
     \hline
    \end{tabular}
    \label{tbl:notations}
\end{table}

\subsection{UPRESSO Overview}
\label{implementations}
UPRESSO contains four sub-protocols, i.e., system initialization, RP initial registration, user registration and SSO login.
The system initialization is invoked by the IdP to initialize the SSO system and only needs to be invoked once for each SSO system.
The RP initial registration is invoked by each RP to obtain the necessary parameters (a unique identifier $ID_{RP}$ and an RP certificate $Cert_{RP}$) from the IdP and only needs to be invoked once for each RP.
The user registration is only invoked once by each user to create a unique user identifier $ID_U$ and the corresponding credential,
where $ID_U$ is generated by the IdP and only provided to the corresponding user.
While, the SSO login is invoked once a user wants to log in an RP, and therefore will be invoked frequently.
The process for user registration is the same as the one in the typical SSO systems,
therefore, we focus on the processes in  system initialization, RP initial registration and SSO login.
For clarity, we list the used notations  in Table~\ref{tbl:notations}.

\vspace{1mm}\noindent \textbf{System initialization.} The IdP chooses $L$, generates a large prime $p$, a prime $q$ of $L$ bits, and a generator $g$ of order $q$ as  the parameters for the discrete logarithm cryptography~\cite{gallagher2013digital}, and generates one asymmetric key pair ($SK$ denotes the private key and $PK$ is the public key) for the generation of the identity proof and $Cert_{RP}$.
The IdP keeps $SK$ secretly, and provides $p$, $q$, $g$, $L$ with $PK$ as the public parameters.
The values of $p$, $q$, $g$ and $L$ remain the same during the full lifecycle of an SSO system.
While, the asymmetric key pair ($SK$, $PK$) will be updated when necessary. For example, when $SK$ is leaked, IdP must update ($SK$,$PK$).

\vspace{1mm}\noindent\textbf{RP initial registration.}
The RP initial registration is invoked only once by an RP, to apply $ID_{RP}$ and $Cert_{RP}$ from IdP.
The detailed processes are as follows:
\begin{enumerate}
\item RP sends a request $Req_{Cert_{RP}}$ to the IdP. The $Req_{Cert_{RP}}$ contains the RP's endpoint (e.g., URL) for receiving the identity proof.
\item IdP chooses a unique and random $r$ ($1 < r < q$),  calculates $ID_{RP}$ using Equation~\ref{equ:IDRP},  generates the signature $Sig_{SK}$ of [$ID_{RP}, endpoint$] with $SK$, and returns [$ID_{RP}, endpoint, Sig_{SK}$] as $Cert_{RP}$. Here, the $r$ is never leaked.
\item The RP  verifies $Cert_{RP}$ using $PK$,  and stores $ID_{RP}$ with the valid $Cert_{RP}$ for the further use.
\end{enumerate}

\vspace{1mm}\noindent\textbf{SSO login.}
Once a user attempts to log in at an RP, the SSO login is invoked. We use the OIDC implicit protocol flow as an example, to demonstrate  how to integrate the three functions $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$, $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$ into the typical SSO systems.
As shown in Figure~\ref{fig:UPRESSO}, the SSO login sub-protocol contains four phases, RP identifier transforming, RP identifier refreshing, $PID_U$ generation and $Account$ calculation.
In the RP identifier transforming, the user and RP negotiate $PID_{RP}$ based on Diffie-Hellman key exchange~\cite{DiffieH76}, where $PID_{RP}$ is calculated as in Equation~\ref{equ:PIDRP}.
In the RP identifier refreshing, the user registerers the unique  $PID_{RP}$ at IdP.
In the $PID_U$ generation, IdP calculates $PID_U$ with $ID_U$ and $PID_{RP}$ as in Equation~\ref{equ:PIDU}.
And in the $Account$ calculation, the RP derives the unchanged $Account$ as in Equation~\ref{equ:Account}.

\subsection{UPRESSO Protocol flow}
\label{sebsec:loginprocess}
In UPRESSO, the SSO login sub-protocol provides the secure SSO service and prevents both the IdP-based access tracing and RP-based identity linkage.
The protocol, shown in Figure~\ref{fig:process},  prevents the curious IdP from obtaining the RP's identifying information during the interchanges,
  and avoids the adversary to break the security and user's privacy.
Here we introduce the detailed processes for each step in Figure~\ref{fig:process}.

\begin{figure*}
  \centering
  \includegraphics[width=0.85\linewidth]{fig/process.pdf}
  \caption{Process for each user login.}
  \label{fig:process}
\end{figure*}

\vspace{1mm}\noindent\textbf{RP identifier transforming.}
In this phase, the user and RP cooperative to generate $PID_{RP}$ as follows:
\begin{itemize}
  \item The user sends a login request to trigger the negotiation of $PID_{RP}$ (Step 1).
  \item The RP chooses a random $N_{RP}$ ($1 < N_{RP} <q$), calculates $Y_{RP}={ID_{RP}}^{N_{RP}} mod \ p$ (Step 2.1.1); and sends $Cert_{RP}$ with $Y_{RP}$ to the user (Step 2.1.2).
  \item The user checks the $Cert_{RP}$, extracts $ID_{RP}$ from the valid $Cert_{RP}$, chooses a random $N_U$ ($1 < N_U <q$) to calculate $PID_{RP}={Y_{RP}}^{N_{U}} mod \ p$ (Step 2.1.3); and sends $N_U$ with $PID_{RP}$ to the RP (Step 2.1.4).
  \item The RP calculates $PID_{RP}$ with $N_U$ and $Y_{RP}$, checks its consistency with the received one, derives the trapdoor $t={(N_U*N_{RP})}^{-1} \ mod \ q$ (Step 2.1.5); and sends the calculated $PID_{RP}$ to the user (Step 2.1.6).
  \item The user checks the consistency of the received $PID_{RP}$ with the stored one.
\end{itemize}
During the process, the user will halt the login, if  the $Cert_{RP}$ is invalid or the received $PID_{RP}$ is different from the stored one. The RP also halts the process if the $PID_{RP}$ sent by the user is inconsistent with the calculated one.

\vspace{1mm}\noindent\textbf{RP identifier refreshing.}
The user registers $PID_{RP}$ at the IdP as follows.
\begin{itemize}
  \item The user generates an one-time endpoint to hide the RP's endpoint from IdP (Step 2.2.1), and sends the registering request [$Reg$, $PID_{RP}$, one-time endpoint] to the IdP (Step 2.2.2).
  \item The IdP checks $PID_{RP}$, and constructs the response [$RegRes$, $RegMes$, $Sig_{Reg}$] (Step 2.2.3). The $RegRes$ is registration result, and is set as $OK$ only when $PID_{RP}$ is never used before and is of order $q$ module $p$. The $RegMes$ is the same as the dynamic registration response, and contains $PID_{RP}$, the issuing time and valid time. The $Sig_{Reg}$ is the signature for $RegRes$ and $RegMes$ generated by the IdP with $SK$.
  \item The user accepts $RegRes$ directly due to the secure connection with IdP, and forwards the registration result to the RP (Step 2.2.4).
  \item The IdP checks $Sig_{SK}$ and $RegMes$, and accepts $RegRes$ only when $Sig_{Reg}$ is valid, $PID_{RP}$ is the same as the negotiated one, and $RegMes$ is not expired.
\end{itemize}
If $RegRes$ is $OK$, the RP identifier refreshing completes. Otherwise, the user and RP will renegotiate the $PID_{RP}$.

\vspace{1mm}\noindent\textbf{$\mathbf{PID_U}$ generation.}
In this phase, the RP continues the process of the user's login and obtains the $PID_U$ generated by the IdP. The processes are as follows.
\begin{itemize}
  \item The RP uses $PID_{RP}$ and the endpoint to construct an identity proof request, which is the same as the one in  OIDC. (Step 2.3).
  \item The user checks the consistency of the received $PID_{RP}$  with the negotiated one (Step 2.4); replaces the endpoint with the one-time endpoint generated in Step 2.2.1, and sends the modified identity proof request to the IdP (Step 2.5).
  \item The IdP authenticates the user if she hasn't been authenticated (Step 3); checks whether $PID_{RP}$ and the one-time endpoint have been registered,
   calculates $PID_U$ using Equation~\ref{equ:PIDU},  constructs the identity proof [$PID_{RP}$, $PID_U$, $ValTime$, $Attr$,$Sig_{IdProof}$] where $ValTime$ is the valid period, $Attr$ contains the  attributes that the user agrees to provide to the RP, $Sig_{IdProof}$ is the signature of the identity proof generated by IdP with $SK$ (Step 4). Then, the IdP sends the identity proof with the one-time endpoint to the user (Step 5.1).
  \item The user finds  the  endpoint corresponding to the one-time endpoint (Step 5.2),
   and forwards the identity proof to the RP through this endpoint (Step 5.3).
\end{itemize}
The user halts the process if the $PID_{RP}$ in the identity proof request is inconsistent with  the negotiated one.
The IdP rejects the identity proof request, if the $PID_{RP}$ and the one-time endpoint have not been registered.


\vspace{1mm}\noindent\textbf{$\mathbf{Account}$ calculation.}
Finally, RP derives the user's  $Account$ and completes the user's login as follows. The RP performs the checks on the identity proof, including the valid time, correctness of $Sig_{IdProof}$, and   the consistency between $PID_{RP}$ and the  negotiated one. If all the checks pass, the RP extracts $PID_U$, and calculates $Accout$ according to Equation~\ref{equ:Account} (Step 6); and sends the $Success$ as the login result to the user (Step 7). If any check fails, the RP returns the $Fail$ to the user.

\begin{figure}[t]
  \centering
  \includegraphics[width=\linewidth]{fig/overview1.pdf}
  \caption{UPRESSO compatibility with OIDC.}
  \label{fig:UPRESSO}
\end{figure}

\subsection{Compatibility with OIDC}
\label{subsec:compatible}
UPRESSO could be integrated in the traditional SSO systems, to  prevent the IdP-based access tracing and RP-based identity linkage.
The integration doesn't degrade the security and only requires minimal modification.
Here, we use the implicit protocol flow of OIDC as an example to demonstrate the compatibility of UPRESSO with the traditional SSO systems, as shown in Figure~\ref{fig:UPRESSO}.
The further analysis, such as integration with the authorization code flow of OIDC,  is provided in Section~\ref{sec:discussion}.

UPRESSO doesn't introduce any new role, nor change the security assumptions on each role (i.e., user, IdP and RP).

As shown in Figure~\ref{fig:UPRESSO}, in UPRESSO, the SSO protocol for identity proof  (Steps between 2.3 and 7) is the same as in OIDC (Steps between 2 and 7); the formats of identity proof and corresponding request are the same as in OIDC; the correctness checks on the identity proof request at the IdP (i.e., consistency of RP' identifier and endpoint with the registered one) are the same as in OIDC; the correctness checks on the identity proof (i.e., consistency of RP' identifier with the one in the request, integrity, validity time, freshness, and etc.) at the RP are the same as in OIDC.

%以下为描述Step 2.3到7的详细内容.
%That is, the RP construct a request for identity proof (Step 2.3); the user redirects this request to the IdP (Step 2.5); the IdP generates the identity proof (Step 4), and sends it to the user (Step 5.1) who redirects it to the RP (Step 5.3); and finally the RP verifies the identity proof (Step 6).

However, UPRESSO achieves privacy preservation by integrating  $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$, $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$, and  introduces the following modifications on OIDC.

\begin{enumerate}
  \item The identity proof is bound with $PID_{RP}$ instead of $ID_{RP}$, which introduces the RP identifier transforming (Step 2.1)  and RP identifier refreshing (Step 2.2).
  \item The identity proof is designated to one-time endpoint instead of RP's identifying endpoint, which requires the user to register the one-time endpoint in Step 2.2 and replace it with the original endpoint in Step 5.2.
  \item IdP generates $PID_U$ based on ($PID_{RP}$, $ID_U$) instead of ($ID_{RP}$, $ID_U$).
  \item The RP calculates $Account$ from the changing $PID_U$ instead of an unchanged one.
\end{enumerate}

Moreover, the RP identifier refreshing is compatible with the dynamic registration in OIDC, with the following modifications, that it is triggered by the user instead of the RP, adds $PID_{RP}$ in the request and includes a signature $Sig_{Res}$ in the response.

\begin{comment}
\vspace{1mm}\noindent \textbf{Consistency with OIDC.}
As shown in Figure~\ref{fig:UPRESSO}, the architecture of UPRESSO is the same as the one in OIDC. UPRESSO does not introduce any new entity, but only integrates the three function $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$, $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$ into the processes at the IdP, RP, and user.

The formats of the  identity proof and corresponding request, and the verification of the identity proof,  are almost same in OIDC and UPRESSO.
The only difference is that $ID_{RP}$ and endpoint are replaced with the privacy-preserving versions, i.e., $PID_{RP}$ and one-time endpoint, in UPRESSO.
As $PID_{RP}$ is also unique and corresponds exactly to $ID_{RP}$, and one-time endpoint corresponds to the RP's endpoint correctly,
 the binding, integrity and confidentiality of identity proof will also be ensured in UPRESSO, and there is no degradation on the security of OIDC.

\vspace{1mm}\noindent \textbf{Minimal modification to OIDC.}
UPRESSO only requires small modification on OIDC to integrate $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$, $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$.
For $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$, we directly use them to replace original functions for $PPID$ at the IdP and the $Account$ at the RP.
For $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$, we inject a negotiation process and a dynamic registration for each SSO login,
 where the negotiation process between the user and RP generates a $PID_{RP}$,
  while the dynamic registration is used to check the uniqueness of $PID_{RP}$.
In UPRESSO, the dynamic registration is slightly modified as follows: an RP identifer ($PID_{RP}$)  is added in the request, and a signature ($Sig_{Res}$)  is included in the response for its verification at the RP.
\end{comment}




