\section{The Identifier-Transformation Approach of UPPRESSO}
\label{sec:challenge}
In this section, we analyze the challenges to design secure privacy-preserving SSO systems, and provide an overview of the identifier-transformation approach of UPPRESSO.

\subsection{Security Requirements of SSO}
\label{subsec:basicrequirements}
The primary goal of SSO services is to implement secure user authentication~\cite{SPRESSO}, i.e., to ensure that a legitimate user can always log in to an honest RP under her unique account.
To achieve this, every identity proof generated by the IdP should explicitly specify the user authenticated by the IdP (i.e., \textbf{\textit{user identification}}) and the RP to which the user attempts to log in (i.e., \textbf{\textit{RP designation}}). User identification also requires an RP to be able to identify and recognize every authenticated user under her unique account registered at that RP across multiple logins. Moreover, the identify proof should be generated by the trusted IdP and correctly transmitted to the dedicated RP (and the user in some schemes) but not anyone else (i.e., \textbf{\textit{confidentiality}}), and the identify proof should not be modified or forged (i.e., \textbf{\textit{integrity}}). These are the basic security requirements of SSO systems summarized based on theoretical analyses~\cite{ArmandoCCCT08,FettKS16, FettKS17} and practical attacks~\cite{SomorovskyMSKJ12,WangCW12,ArmandoCCCPS13,ZhouE14,WangZLLYLG15,WangZLG16,YangLLZH16,MainkaMS16,MohsenS16,MainkaMSW17,YangLCZ18,YangLS17,ShiWL19}.

Many SSO attacks exploit vulnerabilities in SSO design or implementation to break at least one of these security requirements, %~\cite{ChenPCTKT14, FettKS16,WangCW12,ZhouE14,WangZLG16,YangLLZH16,SomorovskyMSKJ12,MohsenS16}.
so that the adversaries log in to an honest RP as a victim user (called \emph{impersonation attacks}), or allure a victim user to log into an honest RP under the attacker's account (called \emph{identity injection attacks}). For example, Friendcaster used to accept every received identity proof (i.e., a violation of RP designation)~\cite{ExplicatingSDK,ChenPCTKT14}, so a malicious RP could replay the identity proof received from the user for itself and log in to Friendcaster as the victim user~\cite{MohsenS16}. In~\cite{ChenPCTKT14,FettKS16,WangZLG16}, the adversaries could impersonate the victim user with a leaked identity proof (i.e., a violation of confidentiality). It was also reported that some RPs of Google ID SSO accepted user attributes that were not tied to the identity proof (i.e., a potential violation of integrity)\cite{WangCW12}, as a result, an adversary could insert arbitrary attributes (e.g., an email address) into the identity proof to impersonate another user at the RP.


\begin{comment}
We summarize the basic requirements of SSO systems based on existing theoretical analyses~\cite{ArmandoCCCT08,FettKS16, FettKS17} and practical attacks~\cite{SomorovskyMSKJ12,WangCW12,ArmandoCCCPS13,ZhouE14,WangZLLYLG15,WangZLG16,YangLLZH16,MainkaMS16,MohsenS16,MainkaMSW17,YangLCZ18,YangLS17,ShiWL19}. These requirements enable an SSO system to provide qualified authentication services for RPs, through identity proofs.
\begin{itemize}
\item \textbf{User identification.} When a user logs into a certain RP for multiple times by submitting identity proofs, the RP extracts the identical user identifier from these identity proofs, to provide personalized services for this user.
\item \textbf{RP designation.} The designated receiver (or RP) is specified in an identity proof, so that this identity proof is accepted by the visited RP only.
\item \textbf{Integrity and confidentiality.} Only the IdP is trusted to generate identity proofs, RPs do not accept an identity proof with any modification or a forged one. %RPs should only accept the valid identity proof.
Meanwhile, a valid identity proof is transmitted only to the user and the designated RP. % confidentiality of the identity proof is ensured during the transmission among the IdP, user and the designated RP.
\end{itemize}


%These basic requirements are the minimum properties that an SSO system has to provide.
% therefore RPs should be able to identify the user with the help from IdP.
First of all, user identification is necessary for common SSO systems to help the RPs to receive the user's identifier, except the anonymous services.
Any violation of these requirements \cite{SomorovskyMSKJ12,WangCW12,ArmandoCCCPS13,ZhouE14,WangZLLYLG15,WangZLG16,YangLLZH16,MainkaMS16,MohsenS16,MainkaMSW17,YangLCZ18,YangLS17,ShiWL19} result in \emph{impersonation attacks} (i.e., the adversaries log into an honest RP as a victim user) or \emph{identity injection attacks} (i.e., a victim user logs into an honest RP under some attacker's identity).
% and without integrity, the impersonation and identity injection attacks could be constructed easily
% as an adversary could directly modify user's identifier in the identity proof;
If the designated RP is not well specified or verified in identity proofs, the adversaries could deceive an RP to accept the identity proofs generated for other RPs, so that the adversaries would (\emph{a}) impersonate some victim user, by colluding with a malicious RP to obtain such an identity proof and submitting it to the RP, or (\emph{b}) inject such identity proofs in the communications between the victim user and some RP.
   %                  for example, by CSRF~\cite{zeller2008cross}.
Impersonation and identity injection attacks would be successfully launched, if the attackers could arbitrarily modify the user identifiers in identity proofs.
Or, the adversaries could impersonate the victim user by submitting any leaked identity proof to the RP~\cite{ChenPCTKT14,FettKS16,WangZLG16}, if confidentiality is not well ensured.

The design and implementation of a secure SSO system is challenging, while various vulnerabilities have been found and exploited to break at least one requirement~\cite{ChenPCTKT14, FettKS16,WangCW12,ZhouE14,WangZLG16,YangLLZH16,SomorovskyMSKJ12,MohsenS16}.
For example, Friendcaster was found to accept any received identity proof~\cite{ExplicatingSDK,ChenPCTKT14}
(i.e., a violation of RP designation) so that a malicious RP could log into Friendcaster as the victim user by replaying the identity proof received from the user to Friendcaster~\cite{MohsenS16}. \cite{WangCW12} reported that some RPs of Google ID SSO accepted user attributes that were not tied to the identity proof (i.e., a violation of integrity). As a result, a malicious user could insert arbitrary attributes (e.g., an email address) into the identity proof to impersonate another user at the RP.
\end{comment}

%\subsection{The Identity Dilemma of Privacy-Preserving SSO}
\subsection{The Privacy Dilemma in SSO Identity Proofs}
\label{subsec:challenges}

As discussed in Section \ref{sec:intro}, existing SSO systems are vulnerable to IdP-based login tracing and RP-based identity linkage privacy leakage. We argue that a secure and privacy-preserving SSO system should prevent {\em both} types of privacy leakage while satisfying {\em all} four basic security requirements. However, meeting the security and privacy requirements at the same time incurs a dilemma in identity proof
generation.

%Since integrity and confidentiality are ensured by digital signatures of the IdP and TLS communications in the system \cite{OpenIDConnect}, we focus only \emph{user identification} and \emph{RP designation} in the remainder.

In an SSO authentication session, the identity proof is generated by the IdP about the authenticated user and the requesting RP. Let us denote the long-term unique identifiers of the user and the RP as $ID_U$ and $ID_{RP}$, respectively. First, to prevent IdP-based login tracing, the identity proof request should not disclose $ID_{RP}$ to the IdP, since the IdP already knows $ID_U$ after authenticating the user. However, to ensure RP designation, the IdP should bind each identify proof with a one-time pseudo-identifier of the RP (denoted as $PID_{RP}$) generated by the user or the RP, or together. But, it should be computationally infeasible for the IdP to derive $ID_{RP}$ from $PID_{RP}$. Meanwhile, to prevent RP-based identity linkage, the identity proof should not directly contain $ID_U$ or disclose it in any means. This requires the IdP to generate a one-time pseudo-identifier of the user (denoted as $PID_U$) and bind the identity proof with it.  However, to ensure user identification, the requesting RP should be able to recognize the user and link $PID_U$ to her unique account at the RP (denoted as $Account$). But, it should be computationally infeasible for the RP to derive $ID_{U}$ from $PID_{U}$ or $Account$.

We illustrate the relationships between the identifiers, pseudo-identifiers, and the identity proof in Fig.~\ref{fig:IDCorrelation}, where red and green blocks respectively represent long-term identifiers and one-time pseudo-identifiers known to each entity, and the arrows denote how the pseudo-identifiers are obtained. Obviously, a dilemma exists in the SSO login session, that is, the IdP is expected to generate a $PID_U$ for the authenticated user $ID_{U}$ that can be linked to her $Account$ at the requesting RP, without even knowing the RP's identity.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{fig/IDCorrelation.pdf}
  \caption{Identifier transformations in privacy-preserving SSO.}
  \label{fig:IDCorrelation}
\end{figure}


\subsection{The Identifier-transformation Framework and UPPRESSO}
\label{subsec:solutions}

As shown in Fig.~\ref{fig:IDCorrelation}, we convert the secure SSO login problem to an identifier-transformation problem, which aims to design three identifier-transformation functions $\mathcal{F}_{ID_{U} \mapsto PID_U}$, $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$, and $\mathcal{F}_{PID_{U} \mapsto Account}$ appropriately, to compute $PID_U$, $PID_{RP}$ and $Account$ that satisfy the desired security and privacy requirements. To solve the dilemma, the key is to pass some information about the user's $Account$ at an RP to the IdP so that all $PID_U$s dynamically generated for the user during her multiple logins at that RP can correctly link to her $Account$. Meanwhile, such information should not provide additional knowledge for the IdP to infer the RP's real identity (i.e., $ID_{RP}$).

To achieve this goal, UPPRESSO constructs three transformation functions in an integrated way such that $\mathcal{F}_{ID_{U} \mapsto PID_U}$ allows the IdP to generate $PID_U$ based on $ID_U$ and $PID_{RP}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$ allows the RP to derive $Account$ from $PID_U$ and $PID_{RP}$, where (i) in each login session, $PID_{RP}$ helps to link $PID_U$ to $Account$; (ii) in different logins, different $PID_U$s and $PID_{RP}$s are generated to protect privacy; and (iii) $PID_U$s and $PID_{RP}$s are generated cooperatively so that an invariant $Account$ can always be derived for a same user and RP pair.

\begin{comment}
three pseudo-identifiers (i.e., $PID_U$, $PID_{RP}$, and $Account$)
in a \emph{dynamical} and \emph{comprehensive} way,
    based on \emph{static} $ID_U$ and $ID_{RP}$.
% user和RP，协商trapdoor，给$PID_U$, $PID_{RP}$带进来随机因子，同时使得只有trapdoor的RP能够计算得到Account。
That is,
    for a certain user,
in each login process at an RP,
    $PID_U$ and $PID_{RP}$ vary
        to satisfy the requirements of privacy;
but $PID_U$ and $PID_{RP}$ vary synchronously so that identical $Account$s are derived.
In particular,
    the user and the RP negotiate $PID_{RP}$ based on $ID_{RP}$ in each login process,
        and then $PID_{RP}$ is transmitted by the user to the IdP.
        Then, the IdP generates $PID_U$ based on $ID_U$ and also $PID_{RP}$.
At the same time, the RP obtains a private trapdoor in the negotiation,
    which is used to derive $Account$ from $PID_U$.

\end{comment}


%Then, we analyze the generation and use of $PID_U$ and $PID_{RP}$, considering the basic requirements of SSO system.
%\begin{itemize}
%%  \item %What's the requirement considering $PID_{U}$ and $PID_{RP}$ together? $PID_{U}$ and $PID_{RP}$一起考虑时需要满足的。
%%  The generation of $PID_{U}$ and $PID_{RP}$ must ensure the \textbf{user identification},
%%  that is, the RP could derive a same $Account$ with the $PID_{U}$ and $PID_{RP}$ from different logins. We assume RP calculates $Account$ by invoking $\mathcal{F}_{PID_{U} \mapsto Account}$ with $PID_U$, $ID_{RP}$ and $PID_{RP}$.
%
%  \item %Who generates $PID_{RP}$, and what's the requirement? PID_RP可以由RP或者user合作生成，但要保证唯一性。
%  Each $PID_{RP}$ must be globally unique, i.e., only assigned to one RP,  for achieving the \textbf{RP designation}.
%        The user and RP may generate the $PID_{RP}$ separately or cooperatively, through the function $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$.
%        However, both the user and RP must check the uniqueness of $PID_{RP}$ before accept and use it.
%        If either the user or the RP doesn't perform the check, the adversary could make it accept a $PID_{RP}$ same as an RP and then misuse the identity proof.
%        %$PID_{RP}$ is one form of the RP's identifer, and seems unrelated with the user's identifier.
%        %Although, the user may inject the user's information into $PID_{RP}$, these information will be treated as random values at the RP and never be used to calculate $Account$, as the user is not trusted by the RP.
%        %Therefore, we can assume that $PID_{RP}$ is generated through $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ with the parameter $ID_{RP}$.~\footnote{The $PID_{RP}$ may also be related with the previous $PID_{RP}$. We omit the previous $PID_{RP}$ in the parameters as it is also a transformation of $ID_{RP}$.}
%  \item The \textbf{RP designation} further requires that  $PID_{U}$ is bound with either a non-null $PID_{RP}$ or $ID_{RP}$ in identity proof.
%        When $PID_{RP}$  is non-null, IdP builds the identity proof separately and the \textbf{integrity} is also ensured.
%        When $PID_{RP}$  is null, only the user could bind $PID_{U}$ with an RP identifier (i.e., $ID_{RP}$) which is unique and checkable to the RP.
%        In this case, the user who performs the binding, must have a publicly verifiable grant from the IdP, as required by \textbf{integrity}.
%%        The binding and integrity cloud be achieved by existing public key infrastructure.
%   \item The \textbf{RP designation} also requires the identity proof will only be sent to the correct RP.
%       As IdP doesn't know $ID_{RP}$, the user or a third party trusted by the correct RP will ensure this.
%\end{itemize}

\vspace{1mm}\noindent \textbf{Trapdoor user identification.}
Existing SSO solutions always depend on constant $ID_U$ in all identity proofs,
    or RP-specific $PID_U$ that keeps constant for an RP,
    to identify an account in the RP.
UPPRESSO introduces trapdoor user identification,
    while an RP holds a trapdoor $T$ to derive the identical $Accout$ from dynamic $PID_{U}$s in identity proofs.
Intuitively,
the trapdoor $T$ also plays a part in the generations of $PID_{RP}$ and $PID_U$,
%    (i.e., $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$),
    directly or indirectly.

%
%$\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$  is invoked with a trapdoor to generate $PID_{RP}s$ which are independent to IdP (preventing IdP-based login tracing),
% and RP uses $\mathcal{F}_{PID_{U} \mapsto Account}$ with this trapdoor to derive the unchanged $Accout$  from $PID_{U}$s that are generated by IdP with $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$.

\vspace{1mm}\noindent \textbf{Transformed RP designation.}
To bind the dynamic $PID_{RP}$ in identity proofs signed by the IdP,
    the user firstly cooperates with the RP to generate $PID_{RP}$ based on $ID_{RP}$ and then
         registers this transformed RP identifier (i.e., $PID_{RP}$) in the IdP.
The identifier transformation of RP is completely kept secret to the IdP.
Then, the one-time $PID_{RP}$ is bound with $PID_U$ in the identity proof.
$PID_{RP}$ is calculated based on $ID_{RP}$ and the trapdoor,
    so that the RP holding the trapdoor is able to verify the specified receiver of identity proofs
            with
            transformed $PID_{RP}$ but not $ID_{RP}$.



%UPPRESSO splits the RP designation into two steps: IdP designates the identity proof to a transformed RP identifer (i.e., $PID_{RP}$), while the user and RP cooperatively designate a fresh and unique $PID_{RP}$ only to one $ID_{RP}$. Then, each RP only needs to check the designation based on $PID_{RP}$.
%\begin{itemize}
%  \item In the first step, the IdP generates $PID_U$ for $PID_{RP}$ and achieves full privacy-preserving binding (i.e., $PID_U$ with $PID_{RP}$).
%UPPRESSO introduces an efficient one-way (trapdoor) function $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$.
% It allows IdP to  compute $PID_U$ easily,  avoiding the generation of $PID_U$ to be the bottleneck at a high-throughput IdP;
%   and also prevents the RP from finding any information about $ID_U$, which is required by preventing RP-based identity linkage.
%  \item In the second step, the user and RP cooperatively generate a fresh $PID_{RP}$ based on $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and check the uniqueness of the $PID_{RP}$, therefore a fresh and unique $PID_{RP}$ is only mapped to one RP, when at least a correct user or correct RP exists. Moreover, the user needs to extract the correct endpoint of $ID_{RP}$, to ensure that the  identity proof is sent to the only correct RP.
%\end{itemize}

%To meet the above two principles, we need to construct three satisfying functions $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$, $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$, design the protocols between the user, RP and IdP to avoid the privacy leakage during message transmission, and implement the  processing at the user as  required by the transformed RP designation.


\subsection{Existing Privacy-Preserving SSO Solutions}
We use the framework of identifier transformation in Figure \ref{fig:IDCorrelation}
    to explain the designs of existing SSO solutions.
First of all,
    when $PID_U = ID_U$ and $PID_{RP} = ID_{RP}$,
    this framework describes the basic SSO services.
It is also applicable to explain the approaches of privacy-preserving SSO systems,
    including PPID \cite{OpenIDConnect}, BrowserID \cite{BrowserID} and SPRESSO \cite{SPRESSO}.

% and explain why they cannot prevent both IdP-based login tracing and RP-based identity linkage.

\begin{table}[tb]
    \caption{Identifier-transformation in privacy-preserving SSO.}
    \centering
    \setlength{\tabcolsep}{1.2mm}
    \begin{tabular}{|c|c|c|c|}
    \hline
    {\textbf{Solution}} & {\textbf{$PID_{U}$}} & {\textbf{$PID_{RP}$}} & {\textbf{$Account$}}\\
    \hline
    {PPID} & {{$\mathcal{F}(ID_U,ID_{RP})$}} & {{$ID_{RP}$}} & {{$PID_U$}}\\
    \hline
    {SPRESSO} & {{$ID_U$}} & {{$Enc(ID_{RP}|nonce)$}} &{{$ID_U$}}\\
    \hline
    {BrowserID$^\dag$} & {{$ID_U$}} & {{$\bot$}} &{{$ID_U$}}\\
    \hline
    {UPPRESSO} & {{$\mathcal{F}(ID_U, PID_{RP})$}} & {{$\mathcal{F}(ID_{RP}, T)$}} &{{$\mathcal{F}(PID_U, T)$}}\\
    \hline
    \end{tabular}
\flushleft
{\footnotesize
$\dag$: BrowserID binds null $PID_{RP}$ in the identity proofs by the IdP,
    but $ID_{RP}$ is bound in the \emph{subsidiary} identity proof signed by the user.}
    \label{tbl:compare}
\end{table}


%\begin{table}[tb]
%    \caption{Identifier-transformation in privacy-preserving SSO.}
%    \centering
%    \setlength{\tabcolsep}{0.5mm}
%    \begin{tabular}{|c|c|c|c|}
%    \hline
%    {\textbf{Solution}} & {{$\mathcal{F}_{ID_{U} \mapsto PID_{U}}$}} & {{$\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$}} & {{$\mathcal{F}_{PID_{U} \mapsto Account}$}}\\
%    \hline
%    {PPID} & {{$Map[ID_U,ID_{RP}]$ (\checkmark)}} & {{$ID_{RP}$ ($\times$)}} & {{$PID_U$ (\checkmark)}}\\
%    \hline
%    {SPRESSO} & {{$ID_U$ ($\times$)}} & {{$Enc(ID_{RP}||nonce)$} (\checkmark)} &{{$ID_U$ ($\times$)}}\\
%    \hline
%    {BrowserID} & {{$ID_U$ ($\times$)}} & {{$\bot$ (\checkmark)}} &{{$ID_U$ ($\times$)}}\\
%    \hline
%    {UPPRESSO} & {{${PID_{RP}}^{ID_U}$ (\checkmark)}}  & {{${ID_{RP}}^{N_UN_{RP}}$ (\checkmark)}} & {{${PID_{U}}^{T}$ (\checkmark)}}\\
%    \hline
%    \end{tabular}
%    \label{tbl:compare}
%\end{table}



% 将Table 1放到这里来
% 对于BrowserID，说法是：PID_RP = null，但是多了subsidiary identity proof generated by the authenticated user,
% ID_RP in subsidiary identity proof.

% Various solutions~\cite{OpenIDConnect, SAMLIdentifier,BrowserID,SPRESSO}, are proposed, attempting to construct a secure and privacy-preserving SSO system.

PPID prevents only RP-based identity linkage but not IdP-based login tracing,
    where
    $PID_{RP} = ID_{RP}$.
The IdP by itself maintains the deterministic mapping from $ID_U$ to $PID_U$ distinct among different RPs,
    and $Account = PID_U$.

%However, these scheme provide at most two satisfying functions, and therefore fail to prevent either the IdP-based login tracing or RP-based identity linkage.
%\begin{itemize}
%  \item The traditional SSO systems provide no satisfying functions, and therefore fail to protect the user's privacy.
%  \item SAML~\cite{SAMLIdentifier} and OIDC~\cite{OpenIDConnect} provide only the satisfying $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$ .
%        The IdP obtains the $ID_{RP}$ for an RP, and generates the unchanged $PID_{U}$ for the same couple $<ID_{U}$, $ID_{RP}>$,
%        while the $PID_{U}$ are independent for different $ID_{RP}$s.
%  \item BrowserID~\cite{BrowserID} and SPRESSO~\cite{SPRESSO} provide only the satisfying $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$.
%        In BrowserID, IdP obtains a null $PID_{RP}$ and provides $ID_U$ to the RP, therefore each RP obtains the unchanged $Accout$.
%\end{itemize}

%Obliviously, existing attempts fail to provide the complete  privacy.
%The essential reason is that these schemes provide an unchanged value (e.g., $PID_{U}$ in SAML~\cite{SAMLIdentifier} and OIDC~\cite{OpenIDConnect}, or $ID_U$ in BrowserID~\cite{BrowserID} and SPRESSO~\cite{SPRESSO}) for the user's multiple logins at an RP.
%To provide unchanged $PID_{U}$, IdP has to know $ID_{RP}$ and then will be able to identity or link the logins at an RP.
%Providing $ID_U$ to the RP, makes  the collusive RPs easily link the user's logins at different RPs.
%

SPRESSO and BrowserID prevent only IdP-based login tracing but not RP-based identity linkage.
In a login instance of SPRESSO,
 the RP generates $PID_{RP}$ by encrypting $ID_{RP}$ padded with a nonce (i.e., $PID_{RP} = Enc(RP_ID || nonce)$),
    and $PID_{RP}$ is forwarded by the user to the IdP,
    so that $ID_{RP}$ is kept unknown to the IdP and $PID_{RP}$ enables the verification of RP designation.
The IdP of SPRESSO binds constant $ID_U$ in identity proofs for a user's multiple logins no matter which RP the user is visiting,
    and $Account = ID_U$.

The IdP of BrowserID signs identity proofs binding only $ID_U$ but no $PID_{RP}$ or $ID_{RP}$ (i.e., $PID_{RP} = \bot$),
    and IdP-based login tracing is prevented.
On the other hand,
 in order to ensure RP designation with null $PID_{RP}$,
    $ID_{RP}$ is bound in the \emph{subsidiary} identity proof signed by the user instead of the IdP.
The identity proof signed by the IdP authorizes the user to sign subsidiary identity proofs,
    and subsidiary identity proofs are kept confidential to the IdP.
$ID_U$ is bound in each identity proof of BrowserID,
    and then $Account = ID_U$.

As analyzed above,
    none of these solutions provides protections against both IdP-based login tracing and
        RP-based identity linkage.
One of the reasons is that
    they do not explicitly clarify three pseudo-identifiers (i.e., $PID_U$, $PID_{RP}$, and $Account$)
        and then design $\mathcal{F}_{ID_{U} \mapsto PID_U}$,   $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$,
  and $\mathcal{F}_{PID_{U} \mapsto Account}$ comprehensively.
