\section{The Identity-Transformation Approach of UPPRESSO}
\label{sec:challenge}

In this section, we analyze the challenges to design secure privacy-preserving SSO systems,
     and provide an overview of the identity-transformation approach proposed in UPPRESSO.

\subsection{Security Requirements of SSO}
\label{subsec:basicrequirements}
We summarize the basic requirements of SSO systems based on existing theoretical analyses~\cite{ArmandoCCCT08,FettKS16, FettKS17} and practical attacks~\cite{SomorovskyMSKJ12,WangCW12,ArmandoCCCPS13,ZhouE14,WangZLLYLG15,WangZLG16,YangLLZH16,MainkaMS16,MohsenS16,MainkaMSW17,YangLCZ18,YangLS17,ShiWL19}. These requirements enable an SSO system to provide qualified authentication services for RPs,
    through identity proofs.
\begin{itemize}
\item
\textbf{User identification.} When a user logs into a certain RP for multiple times by submitting identity proofs,
 the RP extracts the identical user identifier from these identity proofs,
    to provide personalized services for this user.

\item
\textbf{RP designation.} The designated receiver (or RP) is specified in an identity proof,
    so that this identity proof is accepted by the visited RP only.

\item
\textbf{Integrity and confidentiality.}
 Only the IdP is trusted to generate identity proofs,
 RPs do not accept an identity proof with any modification or a forged one.
%RPs should only accept the valid identity proof.
Meanwhile, a valid identity proof is transmitted only to the user and the designated RP.
% confidentiality of the identity proof is ensured during the transmission among the IdP, user and the designated RP.
\end{itemize}



%These basic requirements are the minimum properties that an SSO system has to provide.
% therefore RPs should be able to identify the user with the help from IdP.
First of all,
    user identification is necessary for common SSO systems to help the RPs to receive the user's identifier, except the anonymous services.
Any violation of these requirements \cite{SomorovskyMSKJ12,WangCW12,ArmandoCCCPS13,ZhouE14,WangZLLYLG15,WangZLG16,YangLLZH16,MainkaMS16,MohsenS16,MainkaMSW17,YangLCZ18,YangLS17,ShiWL19}
    result in
    \emph{impersonation attacks} (i.e., the adversaries log into an honest RP as a victim user)
     or \emph{identity injection attacks} (i.e., a victim user logs into an honest RP under some attacker's identity).
% and without integrity, the impersonation and identity injection attacks could be constructed easily
% as an adversary could directly modify user's identifier in the identity proof;
If the designated RP is not well specified or verified in identity proofs,
    the adversaries could deceive an RP to accept the identity proofs generated for other RPs,
        so that the adversaries would (\emph{a}) impersonate some victim user,
                     by colluding with a malicious RP to obtain such an identity proof and submitting it to the RP,
                     or (\emph{b}) inject such identity proofs in the communications between the victim user and some RP.
   %                  for example, by CSRF~\cite{zeller2008cross}.
Impersonation and identity injection attacks would be successfully launched,
    if the attackers could arbitrarily modify the user identifiers in identity proofs.
Or,
     the adversaries could impersonate the victim user by submitting any leaked identity proof to the RP~\cite{ChenPCTKT14,FettKS16,WangZLG16},
     if confidentiality is not ensured.

The design and implementation of a secure SSO system is challenging,  various vulnerabilities have been found and exploited to break at least one requirement~\cite{ChenPCTKT14, FettKS16,WangCW12,ZhouE14,WangZLG16,YangLLZH16,SomorovskyMSKJ12,MohsenS16}.
For example, Friendcaster was found to accept any received identity proof~\cite{ExplicatingSDK,ChenPCTKT14}
(i.e., a violation of RP designation) so that a malicious RP could log in to Friendcaster as the victim user by replaying the identity proof received from the user to Friendcaster~\cite{MohsenS16}. \cite{WangCW12} reported that some RPs of Google ID SSO accepted user attributes that were not tied to the identity proof (i.e., a potential violation of integrity). As a result, a malicious user could insert arbitrary attributes (e.g., an email address) into the identity proof to impersonate another user at the RP.

\subsection{The Identity Dilemma of Privacy-Preserving SSO}
\label{subsec:challenges}
As mentioned in Section \ref{sec:intro},
    the user privacy is leaked through IdP-based visit tracing or RP-based identity linkage.
Thus, a privacy-preserving SSO system shall prevent these two kinds of user privacy leakage,
    while satisfying four basic security requirements of SSO services.
Since integrity and confidentiality are ensured by digital signatures of the IdP and TLS communications in the system \cite{OpenIDConnect},
    we focus only user identification and RP designation in the remainder.

The pseudo-identifiers of users and RPs (denoted as $PID_U$ and $PID_{RP}$, respectively)
    are introduced,
     as we consider two privacy threats.
To prevent IdP-based visit tracing, % while ensure RP designation,
    the IdP shall be aware of $PID_{RP}$ at most
        and then $ID_{RP}$ is not bound in identity proofs;
    otherwise, if $ID_{RP}$ is disclosed to the IdP,
     it enable IdP-based visit tracing because the user is authenticated by the IdP and $ID_U$ is automatically disclosed.
In order to prevent RP-based identity linkage, % while ensure user identification,
    only $PID_U$ but not $ID_U$ is enclosed in the identity proofs;
        otherwise, collusive RPs will link a user's login activities based on $ID_U$ in received identity proofs.
Finally,
    only the pseudo-identifiers of users and RPs (i.e., at most $PID_U$ and $PID_{RP}$,
     but not $ID_U$ or $ID_{RP}$) are bound by the IdP in identity proofs.

Then, when we consider both the requirements of security and privacy,
it brings the identity dilemma as follows:
    when the IdP is unaware of the visited RP,
        it (\emph{a}) binds $PID_{RP}$ in each identity proof that still enables an RP to verify the specified receiver,
        to ensure RP designation,
        and (\emph{b}) generates $PID_U$s in the identity proofs for a user in multiple logins at an RP,
         which enable the RP to extract the identical user identifier
         (i.e., $Account$), to ensure user identification.
Moreover,
    for a certain user,
    $PID_{RP}$s are different in the multiple logins at an RP, to prevent IdP-based visit tracing,
    $PID_U$s are different when the user visits different RPs, to prevent RP-based identity linkage,
 and $Account$s are RP-specific (i.e., distinct for different RPs).

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{fig/IDCorrelation.pdf}
  \caption{Identity transformations in privacy-preserving SSO.}
  \label{fig:IDCorrelation}
\end{figure}


We explain the relationship between the identifiers, the pseudo-identifiers and the identity proof in Figure \ref{fig:IDCorrelation}.
In every login process,
    the user knows both $ID_U$ and $ID_{RP}$.
The IdP is aware of $ID_U$ after it authenticates the user.
Variable $PID_{RP}$ and $PID_U$ are generated for the identity proof,
    satisfying that $PID_{RP}$ enables the verification of RP designation and $PID_{U}$ enables the derivation of identical $Account$.
It is worthy noting that when user privacy is not well considered,
    this relationship is simplified.
For example,
in commonly-used OIDC \cite{OpenIDConnect},
    $ID_U$ is directly assigned to $PID_U$,
        or constant RP-specific $PID_U$ is adopted.
    %and $ID_{RP}$ is assigned to $PID_{RP}$,
%        so $ID_U$ and $ID_{RP}$ are directly bound in identity proofs for .


%
%Then, to prevent RP-based identity linkage,
%    $ID_U$ is transformed into $PID_U$ by the IdP and then bound in identity proofs,
%    so that collusive RPs cannot link the user's login activities by comparing $PID_U$s.
%%For example,
%%    PPID follows this strategy to protect user privacy:
%Meanwhile, if RP-based identity linkage is not considered,
%        we assign $ID_U$ to $PID_U$.
%In order to prevent IdP-based visit tracing,
%    one-time $PID_{RP}$ is bound in every login attempt;
%    and $PID_{RP}$ is also known to the visited RP, to verify the specified receiver of identity proofs.
%It is worthy noting that, in this case, $PID_{RP}$ cannot be determined by the IdP which is unaware of the visited RP.
%%    so the user shall forward $PID_{RP}$ to the IdP.
%Again, if IdP-based visit tracing is not a threat,
%    $ID_{RP}$ is assigned to $PID_{RP}$ directly.
%Finally,
%    in any case,
%    $PID_U$s     in the identity proofs for a user in multiple logins at an RP,
%            result in an identical user identifier (i.e., $Account$).
%
%%The above analysis demonstrates that the identifers of the user and RP need to be carefully processed in SSO systems.

\subsection{The Principles of UPPRESSO}
\label{subsec:solutions}
As demonstrated in Figure \ref{fig:IDCorrelation},
to design secure privacy-preserving SSO solutions
    (i.e., solve the identity dilemma of privacy-preserving SSO),
  we need to find out satisfying functions to compute $PID_U$, $PID_{RP}$ and $Account$,
which are denoted as $\mathcal{F}_{ID_{U} \mapsto PID_U}$,   $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$,
  and $\mathcal{F}_{PID_{U} \mapsto Account}$, respectively.

%We present UPPRESSO, a secure and privacy-preserving SSO system,
%which prevents the IdP-based access tracing and RP-based identity linkage under the prerequisites that  the basic requirements of SSO systems are satisfied.
First of all,
    UPPRESSO adopts the communication pattern of OpenID Connect,
    and then \emph{integrity} and \emph{confidentiality} of identity proofs are also implemented by digital signatures of the IdP
            and TLS communications in the system.

In order to prevent \emph{IdP-based visit tracing},
    the IdP of UPPRESSO is aware of $PID_{RP}$ but not $ID_{RP}$,
        and it is computationally infeasible for the IdP to derive (any information about) $ID_{RP}$ from $PID_{RP}$ and $PID_{U}$;
to prevent \emph{RP-based identity linkage},
    an RP accepts identity proofs including $PID_{U}$ but not $ID_{U}$,
     to derive $Account$ distinct among RPs,
        and it is computationally infeasible for the RP to derive (any information about) $ID_{U}$ from $PID_{U}$, $PID_{RP}$ and $Account$.

Finally,
    we attempt to achieve \emph{user identification} and \emph{RP designation},
        by the comprehensive design of identity transformations
         (i.e., $\mathcal{F}_{ID_{U} \mapsto PID_U}$,   $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$,
  and $\mathcal{F}_{PID_{U} \mapsto Account}$) as follows.
\begin{itemize}
\item
$\mathcal{F}_{ID_{U} \mapsto PID_U}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$
    work together to ensure user identification,
    i.e.,
    derive identical $Account$ for a user in multiple logins at an RP.

%  \item For an RP, $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ generates $PID_{RP}$s in multiple logins, and these  $PID_{RP}$s are independent to the IdP.
%  \item For a user, $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ generates $PID_{U}$s in multiple logins at different RPs, and these $PID_{U}$s are independent to these RPs. $\mathcal{F}_{PID_{U} \mapsto Account}$ outputs $Account$s for a user at different RPs, and these $Account$ are independent to these RPs.
%  \item For a user and an RP, $\mathcal{F}_{PID_{U} \mapsto Account}$ generates a unchanged $Account$ in multiple logins.

\item
 $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ ensures RP designation,
    i.e., $PID_{RP}$ is enough to specify a certain RP.
\end{itemize}


UPPRESSO designs three pseudo-identifiers (i.e., $PID_U$, $PID_{RP}$, and $Account$)
in a \emph{dynamical} and \emph{comprehensive} way,
    based on \emph{static} $ID_U$ and $ID_{RP}$.
% user和RP，协商trapdoor，给$PID_U$, $PID_{RP}$带进来随机因子，同时使得只有trapdoor的RP能够计算得到Account。
That is,
    for a certain user,
in each login process at an RP,
    $PID_U$ and $PID_{RP}$ vary,
        to satisfying the requirements of privacy;
but $PID_U$ and $PID_{RP}$ vary synchronously so that identical $Account$s are derived.
In particular,
    the user and the RP negotiate $PID_{RP}$ based on $ID_{RP}$ in each login process,
        and then $PID_{RP}$ is transmitted to the IdP.
        The IdP generates $PID_U$ based on $ID_U$ and also $PID_{RP}$.
Moreover, the RP obtains a private trapdoor in the negotiation,
    which is used to compute $Account$ from $PID_U$.



%Then, we analyze the generation and use of $PID_U$ and $PID_{RP}$, considering the basic requirements of SSO system.
%\begin{itemize}
%%  \item %What's the requirement considering $PID_{U}$ and $PID_{RP}$ together? $PID_{U}$ and $PID_{RP}$一起考虑时需要满足的。
%%  The generation of $PID_{U}$ and $PID_{RP}$ must ensure the \textbf{user identification},
%%  that is, the RP could derive a same $Account$ with the $PID_{U}$ and $PID_{RP}$ from different logins. We assume RP calculates $Account$ by invoking $\mathcal{F}_{PID_{U} \mapsto Account}$ with $PID_U$, $ID_{RP}$ and $PID_{RP}$.
%
%  \item %Who generates $PID_{RP}$, and what's the requirement? PID_RP可以由RP或者user合作生成，但要保证唯一性。
%  Each $PID_{RP}$ must be globally unique, i.e., only assigned to one RP,  for achieving the \textbf{RP designation}.
%        The user and RP may generate the $PID_{RP}$ separately or cooperatively, through the function $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$.
%        However, both the user and RP must check the uniqueness of $PID_{RP}$ before accept and use it.
%        If either the user or the RP doesn't perform the check, the adversary could make it accept a $PID_{RP}$ same as an RP and then misuse the identity proof.
%        %$PID_{RP}$ is one form of the RP's identifer, and seems unrelated with the user's identifier.
%        %Although, the user may inject the user's information into $PID_{RP}$, these information will be treated as random values at the RP and never be used to calculate $Account$, as the user is not trusted by the RP.
%        %Therefore, we can assume that $PID_{RP}$ is generated through $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ with the parameter $ID_{RP}$.~\footnote{The $PID_{RP}$ may also be related with the previous $PID_{RP}$. We omit the previous $PID_{RP}$ in the parameters as it is also a transformation of $ID_{RP}$.}
%  \item The \textbf{RP designation} further requires that  $PID_{U}$ is bound with either a non-null $PID_{RP}$ or $ID_{RP}$ in identity proof.
%        When $PID_{RP}$  is non-null, IdP builds the identity proof separately and the \textbf{integrity} is also ensured.
%        When $PID_{RP}$  is null, only the user could bind $PID_{U}$ with an RP identifier (i.e., $ID_{RP}$) which is unique and checkable to the RP.
%        In this case, the user who performs the binding, must have a publicly verifiable grant from the IdP, as required by \textbf{integrity}.
%%        The binding and integrity cloud be achieved by existing public key infrastructure.
%   \item The \textbf{RP designation} also requires the identity proof will only be sent to the correct RP.
%       As IdP doesn't know $ID_{RP}$, the user or a third party trusted by the correct RP will ensure this.
%\end{itemize}

\vspace{1mm}\noindent \textbf{Trapdoor user identification.}
Existing SSO solutions always depend on constant $ID_U$ in all identity proofs,
    or RP-specific $PID_U$ that keeps constant for an RP,
    to identify an account in the RP.
UPPRESSO introduces trapdoor user identification,
    while an RP holds a trapdoor to derive the identical $Accout$ from dynamic $PID_{U}$s in identity proofs.
Intuitively,
this trapdoor also works in the generations of $PID_{RP}$ and $PID_U$
%    (i.e., $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$),
    directly or indirectly.

%
%$\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$  is invoked with a trapdoor to generate $PID_{RP}s$ which are independent to IdP (preventing IdP-based access tracing),
% and RP uses $\mathcal{F}_{PID_{U} \mapsto Account}$ with this trapdoor to derive the unchanged $Accout$  from $PID_{U}$s that are generated by IdP with $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$.

\vspace{1mm}\noindent \textbf{Transformed RP designation.}
To bind the dynamic $PID_{RP}$ in identity proofs signed by the IdP,
    the user firstly cooperates with the RP to generate $PID_{RP}$ based on $ID_{RP}$ and then
         registers this transformed RP identifier (i.e., $PID_{RP}$) in the IdP.
The identity transformation of RP is completely kept secret to the IdP.
Then, the one-time $PID_{RP}$ is bound with $PID_U$ in the identity proof.
$PID_{RP}$ is computed based on $ID_{RP}$ and the trapdoor,
    so that the RP holding the trapdoor is able to verify the specified receiver of identity proofs
            with
            transformed $PID_{RP}$ but not $ID_{RP}$.



%UPPRESSO splits the RP designation into two steps: IdP designates the identity proof to a transformed RP identifer (i.e., $PID_{RP}$), while the user and RP cooperatively designate a fresh and unique $PID_{RP}$ only to one $ID_{RP}$. Then, each RP only needs to check the designation based on $PID_{RP}$.
%\begin{itemize}
%  \item In the first step, the IdP generates $PID_U$ for $PID_{RP}$ and achieves full privacy-preserving binding (i.e., $PID_U$ with $PID_{RP}$).
%UPPRESSO introduces an efficient one-way (trapdoor) function $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$.
% It allows IdP to  compute $PID_U$ easily,  avoiding the generation of $PID_U$ to be the bottleneck at a high-throughput IdP;
%   and also prevents the RP from finding any information about $ID_U$, which is required by preventing RP-based identity linkage.
%  \item In the second step, the user and RP cooperatively generate a fresh $PID_{RP}$ based on $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and check the uniqueness of the $PID_{RP}$, therefore a fresh and unique $PID_{RP}$ is only mapped to one RP, when at least a correct user or correct RP exists. Moreover, the user needs to extract the correct endpoint of $ID_{RP}$, to ensure that the  identity proof is sent to the only correct RP.
%\end{itemize}

%To meet the above two principles, we need to construct three satisfying functions $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$, $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$, design the protocols between the user, RP and IdP to avoid the privacy leakage during message transmission, and implement the  processing at the user as  required by the transformed RP designation.


\subsection{Existing SSO Solutions}
We use the framework of identity transformation in Figure \ref{fig:IDCorrelation}
    to explain the designs of different SSO solutions.
First of all,
    when $PID_U = ID_U$ and $PID_{RP} = ID_{RP}$,
    this framework describes commonly-adopted OpenID Connect.
It is also applicable to explain the approaches of existing privacy-preserving SSO solutions,
    including PPID \cite{OpenIDConnect}, BrowserID \cite{BrowserID} and SPRESSO \cite{SPRESSO}.

% and explain why they cannot prevent both IdP-based visit tracing and RP-based identity linkage.

\begin{table}[tb]
    \caption{Three functions in privacy-preserving SSO.}
    \centering
    \setlength{\tabcolsep}{0.5mm}
    \begin{tabular}{|c|c|c|c|}
    \hline
    {Solutions} & {{$\mathcal{F}_{ID_{U} \mapsto PID_{U}}$}} & {{$\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$}} & {{$\mathcal{F}_{PID_{U} \mapsto Account}$}}\\
    \hline
    {PPID} & {{$Map[ID_U,ID_{RP}]$ (\checkmark)}} & {{$ID_{RP}$ ($\times$)}} & {{$PID_U$ (\checkmark)}}\\
    \hline
    {SPRESSO} & {{$ID_U$ ($\times$)}} & {{$Enc(ID_{RP}||nonce)$} (\checkmark)} &{{$ID_U$ ($\times$)}}\\
    \hline
    {BrowserID} & {{$ID_U$ ($\times$)}} & {{$\bot$ (\checkmark)}} &{{$ID_U$ ($\times$)}}\\
    \hline
    {UPPRESSO} & {{${PID_{RP}}^{ID_U}$ (\checkmark)}}  & {{${ID_{RP}}^{N_UN_{RP}}$ (\checkmark)}} & {{${PID_{U}}^{T}$ (\checkmark)}}\\
    \hline
    \end{tabular}
    \label{tbl:compare}
\end{table}
% 将Table 1放到这里来
% 对于BrowserID，说法是：PID_RP = null，但是多了subsidiary identity proof generated by the authenticated user,
% ID_RP in subsidiary identity proof.

% Various solutions~\cite{OpenIDConnect, SAMLIdentifier,BrowserID,SPRESSO}, are proposed, attempting to construct a secure and privacy-preserving SSO system.

PPID prevents only RP-based identity linkage but not IdP-based visit tracing,
    where
    $PID_{RP} = ID_{RP}$.
The IdP by itself maintains the deterministic mapping from $ID_U$ to $PID_U$ distinct for different RPs,
    and $Account = PID_U$.

%However, these scheme provide at most two satisfying functions, and therefore fail to prevent either the IdP-based access tracing or RP-based identity linkage.
%\begin{itemize}
%  \item The traditional SSO systems provide no satisfying functions, and therefore fail to protect the user's privacy.
%  \item SAML~\cite{SAMLIdentifier} and OIDC~\cite{OpenIDConnect} provide only the satisfying $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$ .
%        The IdP obtains the $ID_{RP}$ for an RP, and generates the unchanged $PID_{U}$ for the same couple $<ID_{U}$, $ID_{RP}>$,
%        while the $PID_{U}$ are independent for different $ID_{RP}$s.
%  \item BrowserID~\cite{BrowserID} and SPRESSO~\cite{SPRESSO} provide only the satisfying $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$.
%        In BrowserID, IdP obtains a null $PID_{RP}$ and provides $ID_U$ to the RP, therefore each RP obtains the unchanged $Accout$.
%\end{itemize}

%Obliviously, existing attempts fail to provide the complete  privacy.
%The essential reason is that these schemes provide an unchanged value (e.g., $PID_{U}$ in SAML~\cite{SAMLIdentifier} and OIDC~\cite{OpenIDConnect}, or $ID_U$ in BrowserID~\cite{BrowserID} and SPRESSO~\cite{SPRESSO}) for the user's multiple logins at an RP.
%To provide unchanged $PID_{U}$, IdP has to know $ID_{RP}$ and then will be able to identity or link the logins at an RP.
%Providing $ID_U$ to the RP, makes  the collusive RPs easily link the user's logins at different RPs.
%

SPRESSO and BrowserID prevent only IdP-based visit tracing but not RP-based identity linkage.
In each login process of SPRESSO,
 the RP generates $PID_{RP}$ by encrypting $ID_{RP}$ padded with a nonce (i.e., $PID_{RP} = Enc(RP_ID || nonce)$),
    and $PID_{RP}$ is forwarded by the user to the IdP,
    so that $ID_{RP}$ is kept unknown to the IdP and $PID_{RP}$ enables the verification of RP designation.
The IdP of SPRESSO provides constant $ID_U$ in identity proofs for a user's multiple logins no matter which RP the user is visiting,
    and $Account = ID_U$.

The IdP of BrowserID signs identity proofs binding only $ID_U$ but no $PID_{RP}$ or $ID_{RP}$ (i.e., $PID_{RP} = \bot$),
    and IdP-based visit tracing is prevented.
On the other hand,
 in order to ensure RP designation with null $PID_{RP}$,
    $ID_{RP}$ is bound in the \emph{subsidiary} identity proof signed by the user instead of the IdP.
The identity proof signed by the IdP authorizes the user to sign subsidiary identity proofs,
    and subsidiary identity proofs are kept confidential to the IdP.
$ID_U$ is bound in each identity proof of BrowserID,
    and $Account = ID_U$.

As analyzed above,
    none of these solutions provides protections against both IdP-based access tracing and
        RP-based identity linkage.
One of the reasons is that
    they do not explicitly clarify three pseudo-identifiers (i.e., $PID_U$, $PID_{RP}$, and $Account$)
        and then design $\mathcal{F}_{ID_{U} \mapsto PID_U}$,   $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$,
  and $\mathcal{F}_{PID_{U} \mapsto Account}$ comprehensively.

